<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Builder - Backtest Sample Size Calculator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #fafafa;
            min-height: 100vh;
            padding: 20px;
            color: #1a1a1a;
            position: relative;
        }

        .attribution {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 12px;
            color: #999;
            z-index: 10;
        }

        .attribution a {
            color: #1a1a1a;
            text-decoration: none;
            font-weight: 500;
            transition: opacity 0.2s;
        }

        .attribution a:hover {
            opacity: 0.7;
            text-decoration: underline;
        }

        .attribution .heart {
            display: inline-block;
            font-style: normal;
        }

        .nav-menu {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }

        .nav-menu-dropdown {
            position: relative;
            display: inline-block;
        }

        .nav-menu-button {
            color: #1a1a1a;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            padding: 8px 16px;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            background: white;
            transition: all 0.2s;
            display: inline-block;
            cursor: pointer;
        }

        .nav-menu-button:hover {
            background: #fafafa;
            border-color: #1a1a1a;
        }

        .nav-menu-dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            top: calc(100% + 2px);
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            min-width: 160px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            padding-top: 4px;
            margin-top: -2px;
        }

        .nav-menu-dropdown-content::before {
            content: '';
            position: absolute;
            top: -4px;
            left: 0;
            right: 0;
            height: 4px;
        }

        .nav-menu-dropdown-content a {
            color: #1a1a1a;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            padding: 10px 16px;
            display: block;
            transition: background 0.2s;
        }

        .nav-menu-dropdown-content a:hover {
            background: #fafafa;
        }

        .nav-menu-dropdown-content a:first-child {
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
        }

        .nav-menu-dropdown-content a:last-child {
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
        }

        .twitter-feedback-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 10px 16px;
            text-decoration: none;
            color: #1a1a1a;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }

        .twitter-feedback-button:hover {
            background: #fafafa;
            border-color: #1a1a1a;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .twitter-feedback-button svg {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #fafafa;
        }

        .header {
            background: #fafafa;
            color: #1a1a1a;
            padding: 48px 32px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 20px;
            font-weight: 600;
            letter-spacing: -0.02em;
            line-height: 1.4;
        }

        .header p {
            font-size: 16px;
            color: #666;
            font-weight: 400;
        }

        .content {
            padding: 0px 32px 40px 32px;
            background: #fafafa;
        }

        .calculator {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 32px;
            margin-bottom: 40px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
            color: #1a1a1a;
            font-size: 14px;
        }

        .strategy-item {
            background: #fafafa;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .portfolio-item {
            background: white;
            border: 2px solid #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .portfolio-item.nested {
            border-color: #666;
            border-width: 1px;
        }

        .strategy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .strategy-name {
            font-weight: 600;
            font-size: 16px;
            color: #1a1a1a;
        }

        .portfolio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e5e5e5;
        }

        .portfolio-header .portfolio-name {
            font-weight: 600;
            font-size: 16px;
            color: #1a1a1a;
        }

        .portfolio-items-container {
            margin-top: 16px;
            padding-left: 0;
        }

        .portfolio-items-container.nested {
            padding-left: 16px;
        }

        .strategy-remove {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 18px;
            padding: 4px 8px;
            transition: color 0.2s;
        }

        .strategy-remove:hover {
            color: #1a1a1a;
        }

        .strategy-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }

        .strategy-input-group {
            display: flex;
            flex-direction: column;
        }

        .strategy-input-group label {
            font-size: 12px;
            color: #666;
            margin-bottom: 6px;
        }

        .strategy-input-group input {
            padding: 8px 12px;
            border: 1px solid #d1d1d1;
            border-radius: 6px;
            font-size: 14px;
        }

        .strategy-input-group input:focus {
            outline: none;
            border-color: #1a1a1a;
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
        }


        .drop-zone {
            border: 2px dashed #d1d1d1;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #fafafa;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
            margin-bottom: 16px;
        }

        .drop-zone:hover {
            border-color: #1a1a1a;
            background: #f5f5f5;
        }

        .drop-zone.dragover {
            border-color: #1a1a1a;
            background: #f0f0f0;
        }

        .drop-zone.has-file {
            border-color: #1a1a1a;
            background: white;
            padding: 20px;
        }

        .drop-zone-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 12px auto;
            opacity: 0.6;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .drop-zone-icon svg {
            width: 100%;
            height: 100%;
        }

        .drop-zone-text {
            font-size: 15px;
            color: #666;
            margin-bottom: 8px;
        }

        .drop-zone-hint {
            font-size: 13px;
            color: #999;
        }

        .file-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: #fafafa;
            border-radius: 6px;
            margin-top: 12px;
        }

        .file-name {
            font-size: 14px;
            color: #1a1a1a;
            font-weight: 500;
        }

        .file-remove {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 18px;
            padding: 4px 8px;
            transition: color 0.2s;
        }

        .file-remove:hover {
            color: #1a1a1a;
        }

        .portfolio-settings {
            background: #fafafa;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .portfolio-settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .toggle-label {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #1a1a1a;
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .calculate-btn {
            width: 100%;
            padding: 12px 24px;
            background: #1a1a1a;
            color: white;
            border: 1px solid #1a1a1a;
            border-radius: 6px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            margin-top: 24px;
        }

        .calculate-btn:hover {
            background: #333;
            border-color: #333;
        }

        .calculate-btn:active {
            transform: scale(0.98);
        }

        .calculate-btn:disabled {
            background: #ccc;
            border-color: #ccc;
            cursor: not-allowed;
        }

        .results-container {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 32px;
            margin-top: 24px;
            display: none;
        }

        .results-container.show {
            display: block;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 32px;
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 20px;
        }

        .chart-toggle {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-bottom: 16px;
        }

        .toggle-btn {
            padding: 6px 12px;
            border: 1px solid #d1d1d1;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            color: #666;
        }

        .toggle-btn:hover {
            border-color: #1a1a1a;
            background: #fafafa;
        }

        .toggle-btn.active {
            background: #1a1a1a;
            color: white;
            border-color: #1a1a1a;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 24px;
        }

        .stat-card {
            background: #fafafa;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            padding: 16px;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: #1a1a1a;
        }

        .error-message {
            background: #fff5f5;
            border: 1px solid #feb2b2;
            border-left: 3px solid #f56565;
            padding: 16px;
            border-radius: 6px;
            color: #c53030;
            font-size: 14px;
            margin-top: 16px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 15px;
        }

        .section-title {
            font-size: 18px;
            margin-top: 32px;
            margin-bottom: 16px;
            color: #1a1a1a;
            font-weight: 600;
        }

        .trades-table-container {
            margin-top: 32px;
            overflow-x: auto;
        }

        .trades-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            overflow: hidden;
        }

        .trades-table thead {
            background: #fafafa;
        }

        .trades-table th {
            padding: 12px 16px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #e5e5e5;
        }

        .trades-table td {
            padding: 12px 16px;
            font-size: 14px;
            color: #1a1a1a;
            border-bottom: 1px solid #f0f0f0;
        }

        .trades-table tbody tr:last-child td {
            border-bottom: none;
        }

        .trades-table tbody tr:hover {
            background: #fafafa;
        }

        .trades-table .positive {
            color: #1a1a1a;
        }

        .trades-table .negative {
            color: #666;
        }

        .trades-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            margin-top: 16px;
            padding: 12px;
        }

        .pagination-btn {
            background: white;
            border: 1px solid #d1d1d1;
            border-radius: 6px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #1a1a1a;
            transition: all 0.2s;
        }

        .pagination-btn:hover:not(:disabled) {
            background: #f5f5f5;
            border-color: #1a1a1a;
        }

        .pagination-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .pagination-info {
            font-size: 14px;
            color: #666;
        }

        @media (max-width: 600px) {
            .nav-menu {
                flex-direction: column;
                gap: 4px;
            }

            .strategy-inputs {
                grid-template-columns: 1fr;
            }

            .portfolio-settings-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="attribution">
        made with <span class="heart">‚ù§Ô∏è</span> by <a href="https://stonkscapital.substack.com/" target="_blank">stonks capital</a>
    </div>
    <div class="nav-menu">
        <div class="nav-menu-dropdown">
            <div class="nav-menu-button">Tools</div>
            <div class="nav-menu-dropdown-content">
                <a href="index.html">Sample Size Calculator</a>
                <a href="monte-carlo.html">Monte Carlo</a>
                <a href="correlation.html">Correlation</a>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="header">
            <h1>Portfolio Builder</h1>
            <p>Combine multiple strategies into a single portfolio with risk management</p>
        </div>

        <div class="content">
            <div class="calculator">
                <div class="form-group">
                    <label>Portfolios and Strategies</label>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <button onclick="addPortfolio()" style="padding: 8px 16px; background: #1a1a1a; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px;">+ Add Portfolio</button>
                    </div>
                    <div id="strategies-container"></div>
                    <div class="drop-zone" id="add-strategy-zone">
                        <div class="drop-zone-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="17 8 12 3 7 8"></polyline>
                                <line x1="12" y1="3" x2="12" y2="15"></line>
                            </svg>
                        </div>
                        <div class="drop-zone-text">Drop file here or click to add strategy</div>
                        <div class="drop-zone-hint">Supports .xlsx, .xls, .csv files</div>
                        <input type="file" id="add-strategy-input" accept=".xlsx,.xls,.csv" style="display: none;" multiple>
                    </div>
                </div>

                <div class="portfolio-settings">
                    <h3 style="margin-bottom: 16px; font-size: 16px; font-weight: 600;">Portfolio Settings</h3>
                    <div class="portfolio-settings-grid">
                        <div class="form-group" style="margin-bottom: 0;">
                            <label for="starting-balance">Starting Balance</label>
                            <input type="number" id="starting-balance" min="1000" step="1000" value="100000" style="width: 100%; padding: 10px 14px; border: 1px solid #d1d1d1; border-radius: 6px; font-size: 15px;">
                        </div>
                        <div class="form-group" style="margin-bottom: 0;">
                            <label for="max-trades-day">Max Trades Per Day</label>
                            <input type="number" id="max-trades-day" min="1" step="1" value="10" style="width: 100%; padding: 10px 14px; border: 1px solid #d1d1d1; border-radius: 6px; font-size: 15px;">
                        </div>
                        <div class="form-group" style="margin-bottom: 0;">
                            <label for="max-positions">Max Open Positions</label>
                            <input type="number" id="max-positions" min="1" step="1" value="5" style="width: 100%; padding: 10px 14px; border: 1px solid #d1d1d1; border-radius: 6px; font-size: 15px;">
                        </div>
                    </div>
                    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e5e5e5;">
                        <div style="font-size: 14px; font-weight: 500; margin-bottom: 12px; color: #1a1a1a;">Date Range (Optional)</div>
                        <div class="portfolio-settings-grid">
                            <div class="form-group" style="margin-bottom: 0;">
                                <label for="start-date">Start Date</label>
                                <input type="date" id="start-date" style="width: 100%; padding: 10px 14px; border: 1px solid #d1d1d1; border-radius: 6px; font-size: 15px;">
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label for="end-date">End Date</label>
                                <input type="date" id="end-date" style="width: 100%; padding: 10px 14px; border: 1px solid #d1d1d1; border-radius: 6px; font-size: 15px;">
                            </div>
                        </div>
                        <div style="font-size: 12px; color: #666; margin-top: 8px;">Leave empty to use all available dates</div>
                    </div>
                </div>

                <button class="calculate-btn" id="calculate-btn" onclick="runPortfolioSimulation()" disabled>Build Portfolio</button>

                <div class="error-message" id="error-message"></div>

                <div class="results-container" id="results-container">
                    <div class="loading" id="loading">Building portfolio simulation...</div>
                    <div id="results-content" style="display: none;">
                        <div class="chart-toggle">
                            <button class="toggle-btn active" data-chart="equity-compounded" onclick="toggleChart('equity', 'compounded')">Compounded PnL</button>
                            <button class="toggle-btn" data-chart="equity-log" onclick="toggleChart('equity', 'log')">Log PnL</button>
                        </div>
                        <div class="chart-container">
                            <canvas id="equity-chart"></canvas>
                        </div>
                        <div class="chart-container">
                            <canvas id="drawdown-chart"></canvas>
                        </div>
                        <div class="section-title">Portfolio Statistics</div>
                        <div class="stats-grid" id="stats-grid"></div>
                        <div class="section-title">Strategy Correlation Matrix</div>
                        <div class="trades-table-container" id="correlation-matrix-container"></div>
                        <div class="section-title">Annual Returns</div>
                        <div class="trades-table-container" id="annual-returns-table-container"></div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <div class="section-title" style="margin-bottom: 0;">Executed Trades</div>
                            <button id="download-trades-btn" onclick="downloadTradesExcel()" style="display: none; padding: 8px 16px; background: #1a1a1a; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                                üì• Download Excel
                            </button>
                        </div>
                        <div class="trades-table-container" id="trades-table-container"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let items = []; // Can contain both strategies and portfolios
        let equityChart = null;
        let drawdownChart = null;
        let currentEquityMode = 'compounded';
        let lastResult = null; // Store the last result to use when toggling
        let currentTradesPage = 0;
        let allTrades = [];

        // Setup add strategy drop zone
        function setupAddStrategyZone() {
            const dropZone = document.getElementById('add-strategy-zone');
            const fileInput = document.getElementById('add-strategy-input');

            dropZone.addEventListener('click', () => fileInput.click());

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.xlsx') || f.name.endsWith('.xls') || f.name.endsWith('.csv'));
                files.forEach(file => addStrategy(file));
            });

            fileInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files).filter(f => f.name.endsWith('.xlsx') || f.name.endsWith('.xls') || f.name.endsWith('.csv'));
                files.forEach(file => addStrategy(file));
                e.target.value = '';
            });
        }

        function addStrategy(file, parentPortfolioId = null) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    const strategy = {
                        type: 'strategy',
                        id: Date.now() + Math.random(),
                        name: file.name.replace(/\.(xlsx|xls)$/i, ''),
                        file: file,
                        workbook: workbook,
                        multiplier: 1.0,
                        maxTradesPerDay: 5,
                        maxTradesParallel: 2,
                        parentPortfolioId: parentPortfolioId
                    };

                    if (parentPortfolioId) {
                        const portfolio = findItemById(items, parentPortfolioId);
                        if (portfolio && portfolio.type === 'portfolio') {
                            portfolio.items.push(strategy);
                        }
                    } else {
                        items.push(strategy);
                    }
                    renderStrategies();
                    checkCanCalculate();
                } catch (error) {
                    showError(`Error reading file ${file.name}: ${error.message}`);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function addPortfolio() {
            const portfolio = {
                type: 'portfolio',
                id: Date.now() + Math.random(),
                name: `Portfolio ${items.filter(i => i.type === 'portfolio').length + 1}`,
                items: [],
                maxTradesPerDay: 3,
                maxTradesParallel: 3
            };
            items.push(portfolio);
            renderStrategies();
            checkCanCalculate();
            
            // Scroll to the newly added portfolio
            setTimeout(() => {
                const portfolioElement = document.querySelector(`[data-portfolio-id="${portfolio.id}"]`);
                if (portfolioElement) {
                    portfolioElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Add a subtle highlight effect
                    portfolioElement.style.transition = 'box-shadow 0.3s ease';
                    portfolioElement.style.boxShadow = '0 0 0 3px rgba(26, 26, 26, 0.2)';
                    setTimeout(() => {
                        portfolioElement.style.boxShadow = '';
                    }, 2000);
                }
            }, 100);
        }

        function findItemById(itemsArray, id) {
            for (const item of itemsArray) {
                if (item.id === id) return item;
                if (item.type === 'portfolio' && item.items) {
                    const found = findItemById(item.items, id);
                    if (found) return found;
                }
            }
            return null;
        }

        function removeItem(id) {
            items = items.filter(i => i.id !== id);
            // Also remove from nested portfolios
            items.forEach(item => {
                if (item.type === 'portfolio' && item.items) {
                    item.items = item.items.filter(i => i.id !== id);
                }
            });
            renderStrategies();
            checkCanCalculate();
        }

        function renderStrategies() {
            const container = document.getElementById('strategies-container');
            container.innerHTML = '';
            renderItems(items, container, false);
        }

        function renderItems(itemsArray, container, isNested) {
            itemsArray.forEach(item => {
                if (item.type === 'strategy') {
                const div = document.createElement('div');
                    div.className = isNested ? 'strategy-item nested' : 'strategy-item';
                div.innerHTML = `
                    <div class="strategy-header">
                            <div class="strategy-name">${item.name}</div>
                            <button class="strategy-remove" onclick="removeItem(${item.id})">√ó</button>
                    </div>
                    <div class="strategy-inputs">
                        <div class="strategy-input-group">
                            <label>Multiplier</label>
                                <input type="number" min="0.1" max="100" step="0.1" value="${item.multiplier || 1.0}" 
                                       onchange="updateItem(${item.id}, 'multiplier', this.value)" 
                                       onblur="updateItem(${item.id}, 'multiplier', this.value)"
                                       oninput="updateItem(${item.id}, 'multiplier', this.value)"
                                   placeholder="1.0" title="PnL multiplier: if PnL is $100 and multiplier is 2x, scaled PnL = $200">
                        </div>
                        <div class="strategy-input-group">
                            <label>Max Trades Per Day</label>
                                <input type="number" min="1" step="1" value="${item.maxTradesPerDay}" 
                                       onchange="updateItem(${item.id}, 'maxTradesPerDay', this.value)">
                        </div>
                        <div class="strategy-input-group">
                            <label>Max Trades Parallel</label>
                                <input type="number" min="1" step="1" value="${item.maxTradesParallel}" 
                                       onchange="updateItem(${item.id}, 'maxTradesParallel', this.value)">
                        </div>
                    </div>
                `;
                container.appendChild(div);
                } else if (item.type === 'portfolio') {
                    const div = document.createElement('div');
                    div.className = isNested ? 'portfolio-item nested' : 'portfolio-item';
                    div.setAttribute('data-portfolio-id', item.id);
                    
                    const itemsContainer = document.createElement('div');
                    itemsContainer.className = isNested ? 'portfolio-items-container nested' : 'portfolio-items-container';
                    
                    div.innerHTML = `
                        <div class="portfolio-header">
                            <div>
                                <div class="portfolio-name">${item.name}</div>
                                <div style="font-size: 12px; color: #666; margin-top: 4px;">Portfolio</div>
                            </div>
                            <button class="strategy-remove" onclick="removeItem(${item.id})">√ó</button>
                        </div>
                        <div class="portfolio-settings-grid" style="margin-bottom: 16px;">
                            <div class="form-group" style="margin-bottom: 0;">
                                <label>Portfolio Name</label>
                                <input type="text" value="${item.name}" 
                                       onchange="updateItem(${item.id}, 'name', this.value)"
                                       style="width: 100%; padding: 8px 12px; border: 1px solid #d1d1d1; border-radius: 6px; font-size: 14px;">
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label>Max Trades Per Day</label>
                                <input type="number" min="1" step="1" value="${item.maxTradesPerDay}" 
                                       onchange="updateItem(${item.id}, 'maxTradesPerDay', this.value)"
                                       style="width: 100%; padding: 8px 12px; border: 1px solid #d1d1d1; border-radius: 6px; font-size: 14px;">
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label>Max Trades Parallel</label>
                                <input type="number" min="1" step="1" value="${item.maxTradesParallel}" 
                                       onchange="updateItem(${item.id}, 'maxTradesParallel', this.value)"
                                       style="width: 100%; padding: 8px 12px; border: 1px solid #d1d1d1; border-radius: 6px; font-size: 14px;">
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <button onclick="addStrategyToPortfolio(${item.id})" style="padding: 6px 12px; background: #1a1a1a; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">+ Add Strategy to Portfolio</button>
                        </div>
                    `;
                    div.appendChild(itemsContainer);
                    container.appendChild(div);
                    renderItems(item.items || [], itemsContainer, true);
                }
            });
        }

        function addStrategyToPortfolio(portfolioId) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.xlsx,.xls,.csv';
            input.multiple = true;
            input.onchange = (e) => {
                const files = Array.from(e.target.files).filter(f => f.name.endsWith('.xlsx') || f.name.endsWith('.xls') || f.name.endsWith('.csv'));
                files.forEach(file => addStrategy(file, portfolioId));
            };
            input.click();
        }

        function updateItem(id, field, value) {
            const item = findItemById(items, id);
            if (item) {
                if (field === 'name') {
                    item[field] = value;
                } else {
                const numValue = parseFloat(value);
                if (!isNaN(numValue) && numValue > 0) {
                        item[field] = numValue;
                        console.log(`Updated ${item.type} ${item.name}: ${field} = ${item[field]}`);
                } else if (field === 'multiplier') {
                        item[field] = 1.0;
                        console.warn(`Invalid multiplier for ${item.name}, reset to 1.0`);
                    }
                }
            }
        }

        function checkCanCalculate() {
            const btn = document.getElementById('calculate-btn');
            const hasItems = items.length > 0 || items.some(item => item.type === 'portfolio' && item.items && item.items.length > 0);
            btn.disabled = !hasItems;
        }

        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
            setTimeout(() => {
                errorDiv.classList.remove('show');
            }, 5000);
        }

        // Standardized date parsing function
        function parseExcelDate(value) {
            // Handle Excel serial numbers (days since 1900-01-01)
            if (typeof value === 'number') {
                // Excel epoch is 1900-01-01, but Excel incorrectly treats 1900 as a leap year
                // JavaScript Date uses 1970-01-01, so we need to adjust
                const excelEpoch = new Date(1899, 11, 30); // Dec 30, 1899 (Excel's epoch - 1 day)
                const date = new Date(excelEpoch.getTime() + value * 24 * 60 * 60 * 1000);
                date.setHours(0, 0, 0, 0);
                return date;
            }
            
            // Handle date strings and Date objects
            if (value instanceof Date) {
                const date = new Date(value);
                date.setHours(0, 0, 0, 0);
                return date;
            }
            
            if (typeof value === 'string') {
                // Try parsing the string directly
                let date = new Date(value);
                if (!isNaN(date.getTime())) {
                    // If the string contains a time component (has space and colon), preserve it
                    // Otherwise, set to midnight
                    if (!value.includes(' ') || !value.includes(':')) {
                    date.setHours(0, 0, 0, 0);
                    }
                    return date;
                }
                
                // Try common date formats
                // Format: "YYYY-MM-DD HH:MM" or "YYYY-MM-DD"
                const dateMatch = value.match(/^(\d{4}-\d{2}-\d{2})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?/);
                if (dateMatch) {
                    const dateStr = dateMatch[1];
                    const hour = dateMatch[2] ? parseInt(dateMatch[2]) : 0;
                    const minute = dateMatch[3] ? parseInt(dateMatch[3]) : 0;
                    const second = dateMatch[4] ? parseInt(dateMatch[4]) : 0;
                    date = new Date(dateStr);
                    if (!isNaN(date.getTime())) {
                        date.setHours(hour, minute, second, 0);
                        return date;
                    }
                }
            }
            
            return null;
        }

        // Reuse Excel loading functions from correlation page
        function findColumnByKeywords(df, keywords) {
            for (let col of df.columns) {
                const colStr = String(col).toLowerCase();
                for (let keyword of keywords) {
                    if (colStr.includes(keyword.toLowerCase())) {
                        return col;
                    }
                }
            }
            return null;
        }

        function loadStrategyTrades(workbook) {
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            const data = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null });

            if (data.length === 0) {
                throw new Error('No data found');
            }

            const headers = data[0];
            const rows = data.slice(1);
            
            const df = {
                columns: headers,
                data: rows.map(row => {
                    const obj = {};
                    headers.forEach((header, idx) => {
                        obj[header] = row[idx];
                    });
                    return obj;
                })
            };

            // Find base date column
            let dateCol = findColumnByKeywords(df, ['date']);
            if (dateCol) {
                // Check if it's actually a date column
                const sample = df.data.slice(0, 10).map(row => row[dateCol]);
                    const hasDates = sample.some(val => {
                        if (!val) return false;
                        const d = parseExcelDate(val);
                        return d && d.getFullYear() > 1900;
                    });
                if (!hasDates) dateCol = null;
            }

            // Find exit date/time columns
            // First try to find explicit exit date columns
            let exitDateCol = findColumnByKeywords(df, ['exit_date', 'exit date', 'close_date', 'close date']);
            let exitTimeCol = findColumnByKeywords(df, ['exit_time', 'exit time', 'close_time', 'close time']);
            
            // If we found exit_time but no exit_date, check if exit_time column actually contains dates
            if (!exitDateCol && exitTimeCol) {
                const sample = df.data.slice(0, 10).map(row => row[exitTimeCol]).filter(v => v != null);
                const hasDates = sample.some(val => {
                    if (!val) return false;
                    const d = parseExcelDate(val);
                    return d && d.getFullYear() > 1900;
                });
                if (hasDates) {
                    // exit_time column actually contains dates, use it as exitDateCol
                    exitDateCol = exitTimeCol;
                    exitTimeCol = null; // Don't treat it as a separate time column
                } else if (dateCol) {
                    // exit_time is just time, combine with date column
                    exitDateCol = dateCol;
                }
            }
            
            // If still no exitDateCol, try broader search
            if (!exitDateCol) {
                exitDateCol = findColumnByKeywords(df, ['exit', 'close']);
                // Check if this column actually contains dates
                if (exitDateCol) {
                    const sample = df.data.slice(0, 10).map(row => row[exitDateCol]).filter(v => v != null);
                    const hasDates = sample.some(val => {
                        if (!val) return false;
                        const d = parseExcelDate(val);
                        return d && d.getFullYear() > 1900;
                    });
                    if (!hasDates) {
                        exitDateCol = null; // Not a date column
                    }
                }
            }
            
            // Final fallback to date column
            if (!exitDateCol) {
                exitDateCol = dateCol;
            }

            if (!exitDateCol) {
                // List available columns for debugging
                const availableCols = df.columns.map(c => String(c)).join(', ');
                throw new Error(`No exit date column found. Looking for: exit_date, exit date, exit_time, exit time, exit, close, or date. Available columns: ${availableCols}`);
            }

            // Find entry date/time columns
            // First try to find explicit entry date columns
            let entryDateCol = findColumnByKeywords(df, ['entry_date', 'entry date', 'open_date', 'open date']);
            let entryTimeCol = findColumnByKeywords(df, ['entry_time', 'entry time', 'open_time', 'open time']);
            
            // If we found entry_time but no entry_date, check if entry_time column actually contains dates
            if (!entryDateCol && entryTimeCol) {
                const sample = df.data.slice(0, 10).map(row => row[entryTimeCol]).filter(v => v != null);
                const hasDates = sample.some(val => {
                    if (!val) return false;
                    const d = parseExcelDate(val);
                    return d && d.getFullYear() > 1900;
                });
                if (hasDates) {
                    // entry_time column actually contains dates, use it as entryDateCol
                    entryDateCol = entryTimeCol;
                    entryTimeCol = null; // Don't treat it as a separate time column
                } else if (dateCol) {
                    // entry_time is just time, combine with date column
                    entryDateCol = dateCol;
                }
            }
            
            // If still no entryDateCol, try broader search
            if (!entryDateCol) {
                entryDateCol = findColumnByKeywords(df, ['entry', 'open']);
                // Check if this column actually contains dates
                if (entryDateCol) {
                    const sample = df.data.slice(0, 10).map(row => row[entryDateCol]).filter(v => v != null);
                    const hasDates = sample.some(val => {
                        if (!val) return false;
                        const d = parseExcelDate(val);
                        return d && d.getFullYear() > 1900;
                    });
                    if (!hasDates) {
                        entryDateCol = null; // Not a date column
                    }
                }
            }
            
            // Final fallback to exit date or date column
            if (!entryDateCol) {
                entryDateCol = exitDateCol;
            }

            let pnlCol = findColumnByKeywords(df, ['net_profit', 'net profit', 'net p&l usd', 'pnl', 'p&l', 'profit']);
            if (!pnlCol) {
                pnlCol = findColumnByKeywords(df, ['gain', 'loss', 'return']);
            }

            if (!pnlCol) {
                throw new Error('No PnL column found');
            }

            // Try to find entry, exit, stop loss, and shares columns
            let entryPriceCol = findColumnByKeywords(df, ['entry_price', 'entry price', 'entry', 'buy_price', 'buy price', 'open_price', 'open price']);
            let exitPriceCol = findColumnByKeywords(df, ['exit_price', 'exit price', 'exit', 'sell_price', 'sell price', 'close_price', 'close price']);
            let stopLossCol = findColumnByKeywords(df, ['stop_loss', 'stop loss', 'stop', 'sl']);
            let sharesCol = findColumnByKeywords(df, ['amount', 'shares', 'quantity', 'qty', 'size']);
            let symbolCol = findColumnByKeywords(df, ['symbol', 'ticker', 'instrument', 'stock', 'asset']);

            const trades = df.data
                .filter(row => {
                    // Skip completely empty rows
                    const hasAnyValue = Object.values(row).some(val => val != null && val !== '');
                    if (!hasAnyValue) return false;
                    
                    // Check if exitDate column has a value (or can be derived from date column)
                    const exitDateValue = row[exitDateCol];
                    const dateValue = dateCol ? row[dateCol] : null;
                    if (exitDateValue == null && dateValue == null) {
                        return false; // Skip rows without any date
                    }
                    
                    // Check if PnL column has a value
                    if (row[pnlCol] == null) {
                        return false; // Skip rows without PnL
                    }
                    
                    return true;
                })
                .map(row => {
                    // Combine date with time if we have time columns
                    let exitDateValue = row[exitDateCol];
                    let entryDateValue = entryDateCol ? row[entryDateCol] : exitDateValue;
                    
                    // Handle null/undefined values
                    if (exitDateValue == null && dateCol) {
                        exitDateValue = row[dateCol];
                    }
                    if (entryDateValue == null && exitDateValue != null) {
                        entryDateValue = exitDateValue;
                    }
                    
                    // If we have time columns, combine date + time
                    if (exitTimeCol && row[exitTimeCol] && dateCol && exitDateValue) {
                        const dateStr = String(row[dateCol] || exitDateValue || '');
                        const timeStr = String(row[exitTimeCol] || '');
                        // Combine date and time (e.g., "2008-01-24" + "15:55" = "2008-01-24 15:55")
                        if (dateStr && timeStr) {
                            exitDateValue = `${dateStr} ${timeStr}`.trim();
                        }
                    }
                    
                    if (entryTimeCol && row[entryTimeCol] && dateCol && entryDateCol === dateCol && entryDateValue) {
                        const dateStr = String(row[dateCol] || entryDateValue || '');
                        const timeStr = String(row[entryTimeCol] || '');
                        if (dateStr && timeStr) {
                            entryDateValue = `${dateStr} ${timeStr}`.trim();
                        }
                    }
                    
                    return {
                        exitDate: exitDateValue,
                        entryDate: entryDateValue,
                    pnl: row[pnlCol],
                    entryPrice: entryPriceCol ? row[entryPriceCol] : null,
                    exitPrice: exitPriceCol ? row[exitPriceCol] : null,
                    stopLoss: stopLossCol ? row[stopLossCol] : null,
                        shares: sharesCol ? row[sharesCol] : null,
                        symbol: symbolCol ? row[symbolCol] : null
                    };
                })
                .filter(row => {
                    // Final validation - these should all pass now, but double-check
                    if (row.exitDate == null) {
                        return false;
                    }
                    if (row.pnl == null || isNaN(parseFloat(row.pnl))) {
                        return false;
                    }
                    return true;
                })
                .map(row => {
                    const exitDate = parseExcelDate(row.exitDate);
                    let entryDate = row.entryDate ? parseExcelDate(row.entryDate) : exitDate; // Use exit date as entry if not provided
                    const pnl = parseFloat(row.pnl);
                    
                    if (!exitDate) {
                        console.warn(`Failed to parse exit date: ${row.exitDate}`);
                        return null;
                    }
                    if (isNaN(pnl)) {
                        console.warn(`Failed to parse PnL: ${row.pnl}`);
                        return null;
                    }
                    
                    // Validate entry date is before or equal to exit date
                    if (entryDate && entryDate > exitDate) {
                        console.warn(`Trade has entry date after exit date, using exit date as entry: ${entryDate.toLocaleDateString()} > ${exitDate.toLocaleDateString()}`);
                        entryDate = exitDate;
                    }
                    
                    // Calculate return percentage if we have entry and exit prices
                    let returnPercent = null;
                    if (row.entryPrice != null && row.exitPrice != null) {
                        const entryPrice = parseFloat(row.entryPrice);
                        const exitPrice = parseFloat(row.exitPrice);
                        if (!isNaN(entryPrice) && !isNaN(exitPrice) && entryPrice > 0) {
                            returnPercent = (exitPrice - entryPrice) / entryPrice;
                        }
                    }
                    
                    // Calculate actual risk % if we have entry, stop loss, and shares
                    let actualRiskPercent = null;
                    if (row.entryPrice != null && row.stopLoss != null && row.shares != null) {
                        const entryPrice = parseFloat(row.entryPrice);
                        const stopLoss = parseFloat(row.stopLoss);
                        const shares = parseFloat(row.shares);
                        if (!isNaN(entryPrice) && !isNaN(stopLoss) && !isNaN(shares) && shares > 0) {
                            // Actual $ risk = |stop_loss - entry_price| * shares
                            const riskPerShare = Math.abs(stopLoss - entryPrice);
                            const actualRiskDollars = riskPerShare * shares;
                            // We'll calculate risk % when we have the backtest balance
                            actualRiskDollars; // Store for later use
                        }
                    }
                    
                    return { 
                        entryDate: entryDate || exitDate, // Fallback to exit date if entry date parsing failed
                        exitDate: exitDate,
                        pnl, 
                        originalEntryDate: row.entryDate || row.exitDate,
                        originalExitDate: row.exitDate,
                        returnPercent,
                        entryPrice: row.entryPrice ? parseFloat(row.entryPrice) : null,
                        stopLoss: row.stopLoss ? parseFloat(row.stopLoss) : null,
                        shares: row.shares ? parseFloat(row.shares) : null,
                        symbol: row.symbol ? String(row.symbol) : null
                    };
                })
                .filter(row => row != null)
                .sort((a, b) => a.entryDate.getTime() - b.entryDate.getTime());

            if (trades.length === 0) {
                console.error('No valid trades found after parsing.');
                console.log('Available columns:', df.columns);
                if (df.data.length > 0) {
                    console.log('Sample row:', df.data[0]);
                    console.log('exitDateCol:', exitDateCol);
                    console.log('entryDateCol:', entryDateCol);
                    console.log('exitTimeCol:', exitTimeCol);
                    console.log('entryTimeCol:', entryTimeCol);
                    console.log('dateCol:', dateCol);
                    console.log('pnlCol:', pnlCol);
                }
            } else {
                console.log(`Successfully loaded ${trades.length} trades`);
            }

            return trades;
        }

        function collectAllStrategies(itemsArray, parentPortfolio = null) {
            const allStrategies = [];
            itemsArray.forEach(item => {
                if (item.type === 'strategy') {
                    allStrategies.push({
                        ...item,
                        parentPortfolio: parentPortfolio
                    });
                } else if (item.type === 'portfolio') {
                    // Recursively collect strategies from nested portfolios
                    const nestedStrategies = collectAllStrategies(item.items || [], item);
                    allStrategies.push(...nestedStrategies);
                }
            });
            return allStrategies;
        }

        function runPortfolioSimulation() {
            const allStrategies = collectAllStrategies(items);
            if (allStrategies.length === 0) {
                showError('Please add at least one strategy');
                return;
            }

            const resultsContainer = document.getElementById('results-container');
            const loadingDiv = document.getElementById('loading');
            const resultsContent = document.getElementById('results-content');
            
            resultsContainer.classList.add('show');
            loadingDiv.style.display = 'block';
            resultsContent.style.display = 'none';

            setTimeout(() => {
                try {
                    // Load all strategy trades from nested structure
                    let strategyTrades = allStrategies.map(s => {
                        const trades = loadStrategyTrades(s.workbook);
                        return {
                            id: s.id,
                            name: s.name,
                            multiplier: s.multiplier || 1.0,
                            maxTradesPerDay: s.maxTradesPerDay,
                            maxTradesParallel: s.maxTradesParallel,
                            parentPortfolio: s.parentPortfolio,
                            trades: trades
                        };
                    });
                    
                    // Apply date range filter if specified
                    const startDateInput = document.getElementById('start-date').value;
                    const endDateInput = document.getElementById('end-date').value;
                    
                    if (startDateInput || endDateInput) {
                        const startDate = startDateInput ? new Date(startDateInput) : null;
                        const endDate = endDateInput ? new Date(endDateInput) : null;
                        
                        if (startDate) startDate.setHours(0, 0, 0, 0);
                        if (endDate) endDate.setHours(23, 59, 59, 999);
                        
                        // Validate date range
                        if (startDate && endDate && startDate > endDate) {
                            throw new Error('Start date must be before or equal to end date');
                        }
                        
                        // Filter trades by date range
                        strategyTrades = strategyTrades.map(st => {
                            const filteredTrades = st.trades.filter(trade => {
                                const entryDate = trade.entryDate.getTime();
                                const exitDate = trade.exitDate.getTime();
                                // Include trade if either entry or exit is within range
                                if (startDate && exitDate < startDate.getTime()) return false;
                                if (endDate && entryDate > endDate.getTime()) return false;
                                return true;
                            });
                            return {
                                ...st,
                                trades: filteredTrades
                            };
                        });
                    }
                    
                    // Debug: Log multipliers being used
                    console.log('Strategy multipliers at simulation start:');
                    strategyTrades.forEach(st => {
                        console.log(`  ${st.name}: ${st.multiplier}`);
                    });

                    // Calculate total number of trades (rows in all Excel sheets) after filtering
                    const totalTrades = strategyTrades.reduce((sum, st) => sum + st.trades.length, 0);

                    // Run portfolio simulation with nested portfolio support
                    const result = simulatePortfolioWithNesting(strategyTrades, {
                        startingBalance: parseFloat(document.getElementById('starting-balance').value),
                        maxTradesPerDay: parseInt(document.getElementById('max-trades-day').value),
                        maxOpenPositions: parseInt(document.getElementById('max-positions').value)
                    }, items);

                    // Add total trades and strategy trades to result
                    result.totalTrades = totalTrades;
                    result.strategyTrades = strategyTrades;

                    // Display results
                    displayResults(result);
                    
                    loadingDiv.style.display = 'none';
                    resultsContent.style.display = 'block';
                    
                    setTimeout(() => {
                        resultsContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                } catch (error) {
                    loadingDiv.style.display = 'none';
                    showError(error.message);
                }
            }, 100);
        }

        function simulatePortfolioWithNesting(strategyTrades, topLevelSettings, itemsStructure) {
            // Create a map of portfolio constraints
            const portfolioConstraints = {};
            
            // Build portfolio constraints map from nested portfolios
            strategyTrades.forEach(st => {
                if (st.parentPortfolio) {
                    const portfolioId = st.parentPortfolio.id;
                    if (!portfolioConstraints[portfolioId]) {
                        portfolioConstraints[portfolioId] = {
                            id: portfolioId,
                            name: st.parentPortfolio.name,
                            maxTradesPerDay: st.parentPortfolio.maxTradesPerDay,
                            maxTradesParallel: st.parentPortfolio.maxTradesParallel
                        };
                    }
                }
            });
            
            // Run single simulation with all strategies, respecting portfolio constraints
            return simulatePortfolio(strategyTrades, topLevelSettings, portfolioConstraints);
        }

        function simulatePortfolio(strategyTrades, settings, portfolioConstraints = {}) {
            // Since Excel files contain exit dates and PnL, we treat each trade as closing on its exit date
            // The PnL is already the final result, we just need to scale it by risk %
            
            const equity = [settings.startingBalance];
            const drawdown = [0];
            const dates = [];
            let currentBalance = settings.startingBalance;
            let peak = settings.startingBalance;
            const dailyTrades = {}; // Top-level daily trade counts
            const portfolioDailyCounts = {}; // Track daily counts per portfolio
            const strategyDailyCounts = {}; // Track daily counts per strategy
            const executedTrades = []; // Track all executed trades for the table

            // Initialize portfolio daily counts
            Object.keys(portfolioConstraints).forEach(portfolioId => {
                portfolioDailyCounts[portfolioId] = {};
            });

            // Find the common date range (intersection) across all strategies
            let commonMinDate = null;
            let commonMaxDate = null;
            
            strategyTrades.forEach(st => {
                if (!st.trades || st.trades.length === 0) {
                    console.warn(`Strategy ${st.name} has no trades`);
                    return;
                }
                
                // Find min and max dates for this strategy (consider both entry and exit dates)
                const strategyEntryDates = st.trades.map(t => t.entryDate.getTime());
                const strategyExitDates = st.trades.map(t => t.exitDate.getTime());
                const strategyMin = Math.min(...strategyEntryDates, ...strategyExitDates);
                const strategyMax = Math.max(...strategyEntryDates, ...strategyExitDates);
                
                // Update common range (intersection)
                if (commonMinDate === null) {
                    commonMinDate = strategyMin;
                    commonMaxDate = strategyMax;
                } else {
                    // Intersection: max of all min dates, min of all max dates
                    commonMinDate = Math.max(commonMinDate, strategyMin);
                    commonMaxDate = Math.min(commonMaxDate, strategyMax);
                }
            });
            
            if (commonMinDate === null || commonMaxDate === null || commonMinDate > commonMaxDate) {
                throw new Error('No overlapping date range found across strategies');
            }
            
            // Filter trades to only include those within the common date range
            const commonMinDateObj = new Date(commonMinDate);
            const commonMaxDateObj = new Date(commonMaxDate);
            
            strategyTrades.forEach(st => {
                st.trades = st.trades.filter(t => {
                    const entryDate = t.entryDate.getTime();
                    const exitDate = t.exitDate.getTime();
                    // Include trade if either entry or exit is within range
                    return (entryDate >= commonMinDate && entryDate <= commonMaxDate) ||
                           (exitDate >= commonMinDate && exitDate <= commonMaxDate) ||
                           (entryDate < commonMinDate && exitDate > commonMaxDate); // Trade spans the range
                });
            });
            
            console.log(`Common date range: ${commonMinDateObj.toLocaleDateString()} to ${commonMaxDateObj.toLocaleDateString()}`);
            
            // Get all unique dates from filtered trades (both entry and exit dates)
            const allDates = new Set();
            strategyTrades.forEach(st => {
                st.trades.forEach(t => {
                    allDates.add(t.entryDate.getTime());
                    allDates.add(t.exitDate.getTime());
                });
            });
            
            if (allDates.size === 0) {
                throw new Error('No trades found in common date range');
            }
            
            const sortedDates = Array.from(allDates).sort((a, b) => a - b);

            console.log(`Total dates: ${sortedDates.length}`);
            console.log(`Strategies: ${strategyTrades.length}`);
            strategyTrades.forEach(st => {
                console.log(`Strategy ${st.name}: ${st.trades.length} trades`);
            });

            // Initialize daily counts and open position tracking for all strategies
            const openPositions = {}; // Track open positions per strategy: { strategyId: [trade1, trade2, ...] }
            const portfolioOpenPositions = {}; // Track open positions per portfolio: { portfolioId: count }
            strategyTrades.forEach(st => {
                strategyDailyCounts[st.id] = {};
                openPositions[st.id] = [];
                if (st.parentPortfolio) {
                    const portfolioId = st.parentPortfolio.id;
                    if (!portfolioOpenPositions[portfolioId]) {
                        portfolioOpenPositions[portfolioId] = 0;
                    }
                }
            });

            sortedDates.forEach(dateTime => {
                const date = new Date(dateTime);
                dates.push(date);
                
                // Initialize daily trade count for this date
                if (!dailyTrades[dateTime]) {
                    dailyTrades[dateTime] = 0;
                }

                // Get current daily counts for limit checking
                const currentDayCount = dailyTrades[dateTime] || 0;
                const currentStrategyCounts = {};
                const currentPortfolioCounts = {};
                
                // Count already-executed trades today
                strategyTrades.forEach(st => {
                    currentStrategyCounts[st.id] = strategyDailyCounts[st.id][dateTime] || 0;
                });
                Object.keys(portfolioConstraints).forEach(pid => {
                    currentPortfolioCounts[pid] = portfolioDailyCounts[pid][dateTime] || 0;
                });

                // STEP 1: First, open new positions that enter on this date
                // (We need to open before closing so same-day trades can be opened and then closed)
                const tradesEnteringToday = [];
                strategyTrades.forEach(st => {
                    const portfolioId = st.parentPortfolio ? st.parentPortfolio.id : null;
                    const portfolio = portfolioId ? portfolioConstraints[portfolioId] : null;
                    
                    // Get trades that want to enter today
                    const availableTrades = st.trades.filter(t => t.entryDate.getTime() === dateTime);
                    
                    availableTrades.forEach(trade => {
                        // Check parallel position limits
                        const currentOpenCount = openPositions[st.id].length;
                        if (currentOpenCount >= st.maxTradesParallel) {
                            return; // Strategy has reached its parallel limit
                        }
                        
                        if (portfolio) {
                            const portfolioOpenCount = portfolioOpenPositions[portfolioId] || 0;
                            if (portfolioOpenCount >= portfolio.maxTradesParallel) {
                                return; // Portfolio has reached its parallel limit
                            }
                        }
                        
                        const totalOpenPositions = Object.values(openPositions).reduce((sum, positions) => sum + positions.length, 0);
                        if (totalOpenPositions >= settings.maxOpenPositions) {
                            return; // Top-level has reached its parallel limit
                        }
                        
                        // Check daily limits - if this is a same-day trade, check if we can still execute today
                        const isSameDay = trade.entryDate.getTime() === trade.exitDate.getTime();
                        if (isSameDay) {
                            // This trade will close today, so check daily limits
                            const strategyCount = currentStrategyCounts[st.id] || 0;
                            if (strategyCount >= st.maxTradesPerDay) {
                                return; // Strategy daily limit reached
                            }
                            
                            if (portfolio) {
                                const portfolioCount = currentPortfolioCounts[portfolioId] || 0;
                                if (portfolioCount >= portfolio.maxTradesPerDay) {
                                    return; // Portfolio daily limit reached
                                }
                            }
                            
                            if (currentDayCount >= settings.maxTradesPerDay) {
                                return; // Top-level daily limit reached
                            }
                        }
                        
                        // All checks passed - can open this position
                        tradesEnteringToday.push({
                                    ...trade,
                                    strategyId: st.id,
                            strategy: st,
                            portfolioId: portfolioId
                                });
                            });
                });
                
                // Open positions (randomly shuffled)
                const shuffled = [...tradesEnteringToday].sort(() => Math.random() - 0.5);
                shuffled.forEach(trade => {
                    openPositions[trade.strategyId].push(trade);
                    if (trade.portfolioId) {
                        portfolioOpenPositions[trade.portfolioId] = (portfolioOpenPositions[trade.portfolioId] || 0) + 1;
                    }
                });

                // STEP 2: Now close positions that exit on this date (after opening)
                // This ensures same-day trades can be opened and then closed in the same iteration
                const tradesExitingToday = [];
                strategyTrades.forEach(st => {
                    const portfolioId = st.parentPortfolio ? st.parentPortfolio.id : null;
                    const exitingTrades = st.trades.filter(t => t.exitDate.getTime() === dateTime);
                    
                    exitingTrades.forEach(trade => {
                        // Check if this trade is currently open
                        const openIndex = openPositions[st.id].findIndex(ot => 
                            ot.entryDate.getTime() === trade.entryDate.getTime() &&
                            ot.exitDate.getTime() === trade.exitDate.getTime() &&
                            (ot.symbol === trade.symbol || (!ot.symbol && !trade.symbol))
                        );
                        if (openIndex >= 0) {
                            // Close this position
                            const closedTrade = openPositions[st.id][openIndex];
                            openPositions[st.id].splice(openIndex, 1);
                            
                            // Update portfolio open positions count
                            if (portfolioId) {
                                portfolioOpenPositions[portfolioId] = Math.max(0, portfolioOpenPositions[portfolioId] - 1);
                            }
                            
                            tradesExitingToday.push({
                                ...closedTrade,
                                strategyId: st.id,
                                strategy: st,
                                portfolioId: portfolioId
                            });
                        }
                    });
                });

                // Apply daily limits to exits - limit how many trades can close today
                const shuffledExits = [...tradesExitingToday].sort(() => Math.random() - 0.5);
                const allowedExits = [];
                
                shuffledExits.forEach(trade => {
                    // Check strategy limit
                    if (currentStrategyCounts[trade.strategyId] >= trade.strategy.maxTradesPerDay) {
                        return; // Skip this trade - limit reached
                    }
                    
                    // Check portfolio limit
                    if (trade.portfolioId) {
                        const portfolio = portfolioConstraints[trade.portfolioId];
                        if (currentPortfolioCounts[trade.portfolioId] >= portfolio.maxTradesPerDay) {
                            return; // Skip this trade - limit reached
                        }
                    }
                    
                    // Check top-level limit
                    if (currentDayCount + allowedExits.length >= settings.maxTradesPerDay) {
                        return; // Skip this trade - limit reached
                    }
                    
                    // Can exit this trade
                    allowedExits.push(trade);
                    currentStrategyCounts[trade.strategyId] = (currentStrategyCounts[trade.strategyId] || 0) + 1;
                    if (trade.portfolioId) {
                        currentPortfolioCounts[trade.portfolioId] = (currentPortfolioCounts[trade.portfolioId] || 0) + 1;
                    }
                });

                // Process exiting trades (apply PnL) - only the ones that passed the daily limit check
                allowedExits.forEach(trade => {
                    const balanceRatio = currentBalance / settings.startingBalance;
                    const multiplier = trade.strategy.multiplier || 1.0;
                    const scaledPnL = trade.pnl * multiplier * balanceRatio;
                    
                    currentBalance += scaledPnL;
                    
                    if (currentBalance < 0) {
                        console.warn(`Balance went negative: ${currentBalance.toFixed(2)}, resetting to 0`);
                        currentBalance = 0;
                    }
                    
                    if (currentBalance > peak) peak = currentBalance;
                    
                    // Track trade for table
                    executedTrades.push({
                        entryDate: trade.entryDate,
                        exitDate: trade.exitDate,
                        strategy: trade.strategy.name,
                        symbol: trade.symbol,
                        originalPnL: trade.pnl,
                        adjustedPnL: scaledPnL,
                        balance: currentBalance
                    });
                    
                    // Update counters - count when trade closes (this is when PnL is realized)
                    dailyTrades[dateTime] = (dailyTrades[dateTime] || 0) + 1;
                    if (trade.portfolioId) {
                        if (!portfolioDailyCounts[trade.portfolioId][dateTime]) {
                            portfolioDailyCounts[trade.portfolioId][dateTime] = 0;
                        }
                        portfolioDailyCounts[trade.portfolioId][dateTime]++;
                    }
                    
                    if (!strategyDailyCounts[trade.strategyId][dateTime]) {
                        strategyDailyCounts[trade.strategyId][dateTime] = 0;
                    }
                    strategyDailyCounts[trade.strategyId][dateTime]++;
                });

                equity.push(currentBalance);
                const currentDD = peak > 0 ? (peak - currentBalance) / peak : 0;
                drawdown.push(currentDD);
            });

            // Calculate CAGR
            let cagr = 0;
            if (dates.length > 1) {
                const firstDate = dates[0];
                const lastDate = dates[dates.length - 1];
                const daysDiff = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
                const years = daysDiff / 365.25;
                
                if (years > 0 && currentBalance > 0 && settings.startingBalance > 0) {
                    cagr = (Math.pow(currentBalance / settings.startingBalance, 1 / years) - 1) * 100;
                }
            }

            return {
                dates,
                equity,
                drawdown,
                finalBalance: currentBalance,
                startingBalance: settings.startingBalance,
                totalReturn: ((currentBalance - settings.startingBalance) / settings.startingBalance) * 100,
                maxDrawdown: Math.max(...drawdown) * 100,
                peak,
                cagr,
                executedTrades
            };
        }

        function displayResults(result) {
            // Update stats
            const statsGrid = document.getElementById('stats-grid');
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Final Balance</div>
                    <div class="stat-value">$${result.finalBalance.toLocaleString(undefined, {maximumFractionDigits: 0})}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total Return</div>
                    <div class="stat-value">${result.totalReturn >= 0 ? '+' : ''}${result.totalReturn.toFixed(2)}%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">CAGR</div>
                    <div class="stat-value">${result.cagr >= 0 ? '+' : ''}${result.cagr.toFixed(2)}%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Max Drawdown</div>
                    <div class="stat-value">${result.maxDrawdown.toFixed(2)}%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Peak Balance</div>
                    <div class="stat-value">$${result.peak.toLocaleString(undefined, {maximumFractionDigits: 0})}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Number of Trades</div>
                    <div class="stat-value">${result.totalTrades ? result.totalTrades.toLocaleString() : '0'}</div>
                </div>
            `;

            // Store result for chart toggling
            lastResult = result;
            
            // Create equity chart
            createEquityChart(result, currentEquityMode);
            
            // Create drawdown chart
            createDrawdownChart(result);
            
            // Display correlation matrix
            displayCorrelationMatrix(result.strategyTrades || []);
            
            // Display annual returns table
            displayAnnualReturnsTable(result);
            
            // Display trades table
            displayTradesTable(result.executedTrades || []);
        }

        function calculateAnnualReturns(result) {
            if (!result.dates || result.dates.length === 0 || !result.equity || result.equity.length === 0) {
                return [];
            }

            // Group data by year - track first and last balance for each year
            const yearData = {};
            
            for (let i = 0; i < result.dates.length; i++) {
                const date = result.dates[i];
                const year = date.getFullYear();
                const balance = result.equity[i];
                
                if (!yearData[year]) {
                    // First entry for this year - this is the start balance
                    // But we need to check if there's a previous year's end balance
                    yearData[year] = {
                        year: year,
                        firstBalance: balance,
                        lastBalance: balance,
                        firstDate: date,
                        lastDate: date
                    };
                } else {
                    // Update last balance and date for this year
                    yearData[year].lastBalance = balance;
                    yearData[year].lastDate = date;
                }
            }

            // Calculate returns for each year
            const annualReturns = [];
            const years = Object.keys(yearData).sort((a, b) => parseInt(a) - parseInt(b));
            
            for (let i = 0; i < years.length; i++) {
                const year = parseInt(years[i]);
                const data = yearData[year];
                
                // Determine start balance for this year
                let startBalance;
                if (i === 0) {
                    // First year: use the starting balance from settings
                    // But if the first trade date is not Jan 1, we should use the balance at the start of that year
                    // Actually, equity[0] should be the starting balance, so data.firstBalance should be correct
                    // But to be safe, let's use the starting balance from settings
                    startBalance = result.startingBalance;
                } else {
                    // Subsequent years: use the last balance from the previous year
                    const prevYear = parseInt(years[i - 1]);
                    startBalance = yearData[prevYear].lastBalance;
                }
                
                const endBalance = data.lastBalance;
                let annualReturn = 0;
                
                if (startBalance > 0) {
                    annualReturn = ((endBalance - startBalance) / startBalance) * 100;
                }
                
                annualReturns.push({
                    year: year,
                    return: annualReturn,
                    startBalance: startBalance,
                    endBalance: endBalance
                });
            }

            return annualReturns;
        }

        // Correlation matrix functions
        function pearsonCorrelation(x, y) {
            const n = x.length;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumX2 = x.reduce((a, b) => a + b * b, 0);
            const sumY2 = y.reduce((a, b) => a + b * b, 0);

            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            
            if (denominator === 0) return 0;
            return numerator / denominator;
        }

        function spearmanCorrelation(x, y) {
            // Create ranked arrays
            const rank = (arr) => {
                const sorted = [...arr].map((val, idx) => ({ val, idx })).sort((a, b) => a.val - b.val);
                const ranks = new Array(arr.length);
                sorted.forEach((item, rankIdx) => {
                    ranks[item.idx] = rankIdx + 1;
                });
                return ranks;
            };

            const rx = rank(x);
            const ry = rank(y);
            return pearsonCorrelation(rx, ry);
        }

        function isBusinessDay(date) {
            const day = date.getDay();
            return day !== 0 && day !== 6; // Not Sunday (0) or Saturday (6)
        }

        function getBusinessDaysRange(startDate, endDate) {
            const dates = [];
            const current = new Date(startDate);
            current.setHours(0, 0, 0, 0);
            const end = new Date(endDate);
            end.setHours(0, 0, 0, 0);

            while (current <= end) {
                if (isBusinessDay(current)) {
                    dates.push(new Date(current));
                }
                current.setDate(current.getDate() + 1);
            }
            return dates;
        }

        function extractDailyPnL(strategyTrades) {
            // Aggregate trades by date for each strategy
            const dailyData = {};
            
            strategyTrades.forEach(st => {
                const daily = {};
                st.trades.forEach(trade => {
                    // Use exit date for correlation (when PnL is realized)
                    const dateKey = trade.exitDate.getTime();
                    if (!daily[dateKey]) {
                        daily[dateKey] = 0;
                    }
                    daily[dateKey] += trade.pnl;
                });
                dailyData[st.name] = daily;
            });
            
            return dailyData;
        }

        function alignAllSeries(dailyData) {
            // Find common date range across all strategies
            const allDates = new Set();
            Object.values(dailyData).forEach(daily => {
                Object.keys(daily).forEach(dateKey => allDates.add(parseInt(dateKey)));
            });
            
            if (allDates.size === 0) return [];
            
            const sortedDates = Array.from(allDates).sort((a, b) => a - b);
            const minDate = new Date(Math.min(...sortedDates));
            const maxDate = new Date(Math.max(...sortedDates));
            
            // Create complete business day range
            const allBusinessDays = getBusinessDaysRange(minDate, maxDate);
            
            // Create aligned series
            const aligned = allBusinessDays.map(date => {
                const key = date.getTime();
                const row = { date };
                Object.keys(dailyData).forEach(strategyName => {
                    row[strategyName] = dailyData[strategyName][key] || 0;
                });
                return row;
            });
            
            return aligned;
        }

        function calculateCorrelationMatrix(strategyTrades) {
            if (strategyTrades.length < 2) {
                return null; // Need at least 2 strategies
            }
            
            // Extract daily PnL for each strategy
            const dailyData = extractDailyPnL(strategyTrades);
            
            // Align all series
            const aligned = alignAllSeries(dailyData);
            
            if (aligned.length < 3) {
                return null; // Need at least 3 data points
            }
            
            // Calculate correlation matrix
            const strategyNames = strategyTrades.map(st => st.name);
            const matrix = {};
            
            for (let i = 0; i < strategyNames.length; i++) {
                for (let j = i; j < strategyNames.length; j++) {
                    const name1 = strategyNames[i];
                    const name2 = strategyNames[j];
                    
                    const x = aligned.map(row => row[name1]);
                    const y = aligned.map(row => row[name2]);
                    
                    const corr = spearmanCorrelation(x, y);
                    
                    if (!matrix[name1]) matrix[name1] = {};
                    if (!matrix[name2]) matrix[name2] = {};
                    
                    matrix[name1][name2] = corr;
                    matrix[name2][name1] = corr;
                }
            }
            
            return { matrix, strategyNames, n: aligned.length };
        }

        function displayCorrelationMatrix(strategyTrades) {
            const container = document.getElementById('correlation-matrix-container');
            
            if (!strategyTrades || strategyTrades.length < 2) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Need at least 2 strategies to calculate correlation matrix</div>';
                return;
            }
            
            const result = calculateCorrelationMatrix(strategyTrades);
            
            if (!result) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Not enough overlapping data to calculate correlations</div>';
                return;
            }
            
            const { matrix, strategyNames, n } = result;
            
            let tableHTML = `
                <table class="trades-table">
                    <thead>
                        <tr>
                            <th style="text-align: left;">Strategy</th>
                            ${strategyNames.map(name => `<th style="text-align: center;">${name}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            strategyNames.forEach(name1 => {
                tableHTML += `<tr>`;
                tableHTML += `<td style="font-weight: 600;">${name1}</td>`;
                strategyNames.forEach(name2 => {
                    const corr = matrix[name1][name2];
                    const corrValue = isNaN(corr) ? 'N/A' : corr.toFixed(4);
                    const cellStyle = name1 === name2 
                        ? 'background: #fafafa; text-align: center;' 
                        : 'text-align: center;';
                    tableHTML += `<td style="${cellStyle}">${corrValue}</td>`;
                });
                tableHTML += `</tr>`;
            });
            
            tableHTML += `
                    </tbody>
                </table>
                <div style="margin-top: 12px; font-size: 12px; color: #666; text-align: center;">
                    Spearman correlation based on ${n} aligned trading days
                </div>
            `;
            
            container.innerHTML = tableHTML;
        }

        function displayAnnualReturnsTable(result) {
            const container = document.getElementById('annual-returns-table-container');
            const annualReturns = calculateAnnualReturns(result);
            
            if (annualReturns.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No annual return data available</p>';
                return;
            }

            let tableHTML = `
                <table class="trades-table">
                    <thead>
                        <tr>
                            <th>Year</th>
                            <th>Start Balance</th>
                            <th>End Balance</th>
                            <th>Annual Return</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            annualReturns.forEach(yearData => {
                const returnClass = yearData.return >= 0 ? 'positive' : 'negative';
                const returnSign = yearData.return >= 0 ? '+' : '';
                
                tableHTML += `
                    <tr>
                        <td>${yearData.year}</td>
                        <td>$${yearData.startBalance.toLocaleString(undefined, {maximumFractionDigits: 2})}</td>
                        <td>$${yearData.endBalance.toLocaleString(undefined, {maximumFractionDigits: 2})}</td>
                        <td class="${returnClass}">${returnSign}${yearData.return.toFixed(2)}%</td>
                    </tr>
                `;
            });

            tableHTML += `
                    </tbody>
                </table>
            `;

            container.innerHTML = tableHTML;
        }

        function displayTradesTable(trades) {
            const container = document.getElementById('trades-table-container');
            const downloadBtn = document.getElementById('download-trades-btn');
            
            if (trades.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No trades executed</p>';
                if (downloadBtn) downloadBtn.style.display = 'none';
                return;
            }

            // Store all trades and reset to first page
            allTrades = trades;
            currentTradesPage = 0;
            
            // Show download button
            if (downloadBtn) downloadBtn.style.display = 'block';
            
            renderTradesPage();
        }

        function downloadTradesExcel() {
            if (!allTrades || allTrades.length === 0) {
                alert('No trades to download');
                return;
            }

            // Prepare data for Excel
            const excelData = allTrades.map(trade => {
                const entryDate = trade.entryDate instanceof Date ? trade.entryDate : new Date(trade.entryDate);
                const exitDate = trade.exitDate instanceof Date ? trade.exitDate : new Date(trade.exitDate);
                
                return {
                    'Entry Date': entryDate.toLocaleDateString(),
                    'Entry DateTime': entryDate.toISOString(),
                    'Exit Date': exitDate.toLocaleDateString(),
                    'Exit DateTime': exitDate.toISOString(),
                    'Strategy': trade.strategy || '',
                    'Symbol': trade.symbol || '',
                    'Original PnL': trade.originalPnL || 0,
                    'Adjusted PnL': trade.adjustedPnL || 0,
                    'Balance': trade.balance || 0
                };
            });

            // Create workbook and worksheet
            const ws = XLSX.utils.json_to_sheet(excelData);
            
            // Set column widths
            const colWidths = [
                { wch: 12 }, // Entry Date
                { wch: 20 }, // Entry DateTime
                { wch: 12 }, // Exit Date
                { wch: 20 }, // Exit DateTime
                { wch: 15 }, // Strategy
                { wch: 10 }, // Symbol
                { wch: 15 }, // Original PnL
                { wch: 15 }, // Adjusted PnL
                { wch: 15 }  // Balance
            ];
            ws['!cols'] = colWidths;

            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Executed Trades');

            // Generate filename with timestamp
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `executed_trades_${timestamp}.xlsx`;

            // Download
            XLSX.writeFile(wb, filename);
        }

        function renderTradesPage() {
            const container = document.getElementById('trades-table-container');
            const pageSize = 10;
            const totalPages = Math.ceil(allTrades.length / pageSize);
            const startIdx = currentTradesPage * pageSize;
            const endIdx = Math.min(startIdx + pageSize, allTrades.length);
            const pageTrades = allTrades.slice(startIdx, endIdx);

            let tableHTML = `
                <table class="trades-table">
                    <thead>
                        <tr>
                            <th>Entry Date</th>
                            <th>Exit Date</th>
                            <th>Strategy</th>
                            <th>Symbol</th>
                            <th>Original PnL</th>
                            <th>Adjusted PnL</th>
                            <th>Balance</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            pageTrades.forEach(trade => {
                const entryDate = trade.entryDate instanceof Date ? trade.entryDate.toLocaleDateString() : new Date(trade.entryDate).toLocaleDateString();
                const exitDate = trade.exitDate instanceof Date ? trade.exitDate.toLocaleDateString() : new Date(trade.exitDate).toLocaleDateString();
                const originalPnLClass = trade.originalPnL >= 0 ? 'positive' : 'negative';
                const adjustedPnLClass = trade.adjustedPnL >= 0 ? 'positive' : 'negative';
                
                tableHTML += `
                    <tr>
                        <td>${entryDate}</td>
                        <td>${exitDate}</td>
                        <td>${trade.strategy}</td>
                        <td>${trade.symbol || '-'}</td>
                        <td class="${originalPnLClass}">$${trade.originalPnL.toFixed(2)}</td>
                        <td class="${adjustedPnLClass}">$${trade.adjustedPnL.toFixed(2)}</td>
                        <td>$${trade.balance.toLocaleString(undefined, {maximumFractionDigits: 2})}</td>
                    </tr>
                `;
            });

            tableHTML += `
                    </tbody>
                </table>
                <div class="trades-pagination">
                    <button class="pagination-btn" onclick="firstTradesPage()" ${currentTradesPage === 0 ? 'disabled' : ''} title="First page">
                        &lt;&lt;
                    </button>
                    <button class="pagination-btn" onclick="previousTradesPage()" ${currentTradesPage === 0 ? 'disabled' : ''}>
                        ‚Üê Previous
                    </button>
                    <span class="pagination-info">
                        Showing ${startIdx + 1}-${endIdx} of ${allTrades.length} trades (Page ${currentTradesPage + 1} of ${totalPages})
                    </span>
                    <button class="pagination-btn" onclick="nextTradesPage()" ${currentTradesPage >= totalPages - 1 ? 'disabled' : ''}>
                        Next ‚Üí
                    </button>
                    <button class="pagination-btn" onclick="lastTradesPage()" ${currentTradesPage >= totalPages - 1 ? 'disabled' : ''} title="Last page">
                        &gt;&gt;
                    </button>
                </div>
            `;

            container.innerHTML = tableHTML;
        }

        function firstTradesPage() {
            currentTradesPage = 0;
            renderTradesPage();
        }

        function previousTradesPage() {
            if (currentTradesPage > 0) {
                currentTradesPage--;
                renderTradesPage();
            }
        }

        function nextTradesPage() {
            const pageSize = 10;
            const totalPages = Math.ceil(allTrades.length / pageSize);
            if (currentTradesPage < totalPages - 1) {
                currentTradesPage++;
                renderTradesPage();
            }
        }

        function lastTradesPage() {
            const pageSize = 10;
            const totalPages = Math.ceil(allTrades.length / pageSize);
            currentTradesPage = totalPages - 1;
            renderTradesPage();
        }

        function toggleChart(type, mode) {
            if (type === 'equity') {
                currentEquityMode = mode;
                document.querySelectorAll('[data-chart^="equity-"]').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-chart="equity-${mode}"]`).classList.add('active');
                
                // Use stored result data (always use original equity values, not transformed)
                if (lastResult) {
                    createEquityChart(lastResult, mode);
                }
            }
        }

        function createEquityChart(result, mode) {
            const ctx = document.getElementById('equity-chart').getContext('2d');
            
            if (equityChart) {
                equityChart.destroy();
            }

            let data = result.equity;
            let label = 'Portfolio Equity';
            
            if (mode === 'log') {
                data = result.equity.map(v => Math.log10(Math.max(v, 1)));
                label = 'Portfolio Equity (Log Scale)';
            }

            equityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: result.dates.map(d => d.toLocaleDateString()),
                    datasets: [{
                        label: label,
                        data: data,
                        borderColor: '#1a1a1a',
                        backgroundColor: 'rgba(26, 26, 26, 0.05)',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        tension: 0.1,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Portfolio Equity Curve',
                            font: {
                                size: 14,
                                weight: 600,
                                family: 'Inter'
                            },
                            color: '#1a1a1a'
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Date',
                                font: { size: 12, weight: 500, family: 'Inter' },
                                color: '#666'
                            },
                            grid: { color: '#f0f0f0' },
                            ticks: { color: '#666', font: { family: 'Inter' }, maxTicksLimit: 10 }
                        },
                        y: {
                            title: {
                                display: true,
                                text: mode === 'log' ? 'Log Equity' : 'Balance ($)',
                                font: { size: 12, weight: 500, family: 'Inter' },
                                color: '#666'
                            },
                            grid: { color: '#f0f0f0' },
                            ticks: { 
                                color: '#666', 
                                font: { family: 'Inter' },
                                callback: function(value) {
                                    if (mode === 'log') return value.toFixed(2);
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }

        function createDrawdownChart(result) {
            const ctx = document.getElementById('drawdown-chart').getContext('2d');
            
            if (drawdownChart) {
                drawdownChart.destroy();
            }

            drawdownChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: result.dates.map(d => d.toLocaleDateString()),
                    datasets: [{
                        label: 'Drawdown',
                        data: result.drawdown.map(d => d * 100),
                        borderColor: '#666',
                        backgroundColor: 'rgba(102, 102, 102, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Portfolio Drawdown',
                            font: {
                                size: 14,
                                weight: 600,
                                family: 'Inter'
                            },
                            color: '#1a1a1a'
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Date',
                                font: { size: 12, weight: 500, family: 'Inter' },
                                color: '#666'
                            },
                            grid: { color: '#f0f0f0' },
                            ticks: { color: '#666', font: { family: 'Inter' }, maxTicksLimit: 10 }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Drawdown (%)',
                                font: { size: 12, weight: 500, family: 'Inter' },
                                color: '#666'
                            },
                            grid: { color: '#f0f0f0' },
                            ticks: { 
                                color: '#666', 
                                font: { family: 'Inter' },
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        // Initialize
        setupAddStrategyZone();
        checkCanCalculate();
        
        // Handle Enter key to trigger portfolio build
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
                const btn = document.getElementById('calculate-btn');
                if (btn && !btn.disabled) {
                    e.preventDefault();
                    runPortfolioSimulation();
                }
            }
        });

        // Improve dropdown hover behavior (desktop) and click behavior (mobile)
        (function() {
            const dropdown = document.querySelector('.nav-menu-dropdown');
            if (!dropdown) return;
            
            let hideTimeout;
            const content = dropdown.querySelector('.nav-menu-dropdown-content');
            const button = dropdown.querySelector('.nav-menu-button');
            
            // Detect touch device
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            function showDropdown() {
                clearTimeout(hideTimeout);
                content.style.display = 'block';
            }
            
            function hideDropdown() {
                hideTimeout = setTimeout(() => {
                    content.style.display = 'none';
                }, 200); // 200ms delay before hiding
            }
            
            function toggleDropdown() {
                if (content.style.display === 'block') {
                    hideDropdown();
                } else {
                    showDropdown();
                }
            }
            
            if (isTouchDevice) {
                // Mobile: use click/tap
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleDropdown();
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!dropdown.contains(e.target)) {
                        content.style.display = 'none';
                    }
                });
            } else {
                // Desktop: use hover
                dropdown.addEventListener('mouseenter', showDropdown);
                dropdown.addEventListener('mouseleave', hideDropdown);
            }
        })();
    </script>
    <!-- Vercel Analytics -->
    <script>
        (function() {
            if (typeof window === 'undefined') return;
            var script = document.createElement('script');
            script.src = '/_vercel/insights/script.js';
            script.defer = true;
            script.onerror = function() {
                var fallback = document.createElement('script');
                fallback.src = 'https://va.vercel-scripts.com/v1/script.js';
                fallback.defer = true;
                document.head.appendChild(fallback);
            };
            document.head.appendChild(script);
        })();
    </script>
    <a href="https://x.com/messages/compose?recipient_id=3130204764" target="_blank" rel="noopener noreferrer" class="twitter-feedback-button">
        <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
        </svg>
        <span>Request Feature</span>
    </a>
</body>
</html>

